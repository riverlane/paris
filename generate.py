## This file needs to contain data generation and evaluation functions.

# cont. problems are defined by N qubits and the HW efficent params that generate the |phi>s
# discrete problems are the circuit (by hand)
import projectq.ops as ops
from projectq import MainEngine, cengines
from projectq.backends import Simulator
from qiskit import QuantumCircuit, QuantumRegister, BasicAer, execute

import numpy as np
import itertools
import random
import time

import argparse
parser = argparse.ArgumentParser(description='Generate test sets.')
parser.add_argument('--problems', metavar='P', type=int, nargs='+', default=[0, 1, 2, 3, 4, 5],
                    help='problems to regenerate data for.')

args = parser.parse_args()

np.random.seed(seed=7)

def int_to_basis_element(i, NQ):
    wfn = np.zeros((2**NQ,))
    wfn[i] = 1.0
    return wfn

def generate_pm_space_vectors(NQ, N, circuit):

    basis_states = [i for i in range(0, 2**NQ)]
    evens = [s for s in basis_states if bin(s).count("1") % 2 == 0]
    odds = [s for s in basis_states if bin(s).count("1") % 2 == 1]

    train_set = []
    engine = MainEngine(backend=Simulator(), engine_list=[])

    t0 = time.time()
    for n in range(N):

        if time.time()-t0 > 10:
            print(n, N)
            t0 = time.time()
        # generate a coefficent vector in complex space.
        weights_r = np.random.uniform(low=0.0, high=1.0, size=(2**(NQ-1),) )
        weights_theta = np.random.uniform(low=0.0, high=2*np.pi, size=(2**(NQ-1),) )
        weights = weights_r * np.exp(1j*weights_theta)
        weights /= np.linalg.norm(weights) # normalize

        label = random.choices([-1, 1])[0]
        if label == -1: # 1 == odds
            ket_theta = sum( [coeff * int_to_basis_element(i, NQ=NQ) for coeff, i in zip(weights, odds)] )
        else:
            ket_theta = sum( [coeff * int_to_basis_element(i, NQ=NQ) for coeff, i in zip(weights, evens)] )

        qreg = engine.allocate_qureg(NQ) # make a new simulator
        engine.backend.set_wavefunction(ket_theta, qreg) # we've been given this state.
        engine.flush()
        # print(f"label {label} exp ZZ { engine.backend.get_expectation_value(ops.QubitOperator('Z0 Z1'), qreg) }")

        for gate, idx in circuit:
            if type(gate) is ops._metagates.ControlledGate:
                gate | (qreg[idx][0], qreg[idx][1])
            else:
                gate | qreg[idx] # apply the test gates

        engine.flush()
        _, ket_phi = engine.backend.cheat()
        ops.All(ops.Measure) | qreg # clean up.
        del qreg

        train_set.append( (ket_phi, label) )
    return list(zip(*train_set)) # vectors, labels

def generate_basis_vectors(NQ, circuit):
    basis_states = [i for i in range(0, 2**NQ)]
    evens = [s for s in basis_states if bin(s).count("1") % 2 == 0]
    odds = [s for s in basis_states if bin(s).count("1") % 2 == 1]
    engine = MainEngine(backend=Simulator(), engine_list=[])

    p1_test_v, p1_test_l = [], []
    for state in basis_states:
        label = 1 if bin(state).count("1") % 2 == 0 else -1
        qreg = engine.allocate_qureg(NQ) # make a new simulator
        engine.backend.set_wavefunction(int_to_basis_element(state, NQ), qreg) # we've been given this state.

        for gate, idx in circuit:
            if type(gate) is ops._metagates.ControlledGate:
                gate | (qreg[idx][0], qreg[idx][1])
            else:
                gate | qreg[idx] # apply the test gates

        engine.flush()
        _, ket_phi = engine.backend.cheat(); ops.All(ops.Measure) | qreg; engine.flush(); del qreg
        p1_test_v.append(ket_phi)
        p1_test_l.append(label)
    return p1_test_v, p1_test_l


def add_samples(problem):
    problem["TrainSamples"], problem["TrainLabels"] = generate_pm_space_vectors(NQ=problem["NumQubits"],
                                                                                N=problem["NSamples"],
                                                                                circuit=problem["U"])
    problem["TestVectors"], problem["TestLabels"] = generate_basis_vectors(NQ=problem["NumQubits"],
                                                                           circuit=problem["U"])
    #problem["QuantumMeasurement"] = ops.QubitOperator(" ".join([f"Z{i}" for i in range(problem["NumQubits"])])),
    problem["QuantumMeasurement"] = " ".join(f"Z{i}" for i in range(problem["NumQubits"]))
    return problem


D_problem_0 = {
    "Name":"discrete_problem0",
    "NumQubits":1,

    # The (hidden!) permutation gate, and possibly its inverse? Leave Udag as none if not known
    "U":[(ops.H, 0)], "Udag":[(ops.H, 0)],

    # For the one qubit problem we can only really give the basis elements. Lbels autogenerated
    "NSamples":2, "TrainSamples":[np.array([1, 0]), np.array([0, 1])],
    "TrainLabels":[1, -1],

    # For us: what measurement should be taken. The classical one is a map from a bitstr basis state to the observable
    "QuantumMeasurement":"Z0",
    "TimeEst":0,

    # This stuff should be displyed where the participants can see it.
    "Hint":"""This is the single qubit problem we walked through at the start of the hackathon.
The U circuit we created puts the qubit into a superposition of 0 and 1.
We showed that by applying a Hadamard gate we go back to just one of the states.
"""
}

if 0 in args.problems:
    D_problem_0 = add_samples(D_problem_0)
    print("done 0")

D_problem_1 = {
    "Name":"discrete_problem1",
    "NumQubits":2,
    "U":[(ops.H, 0), (ops.X, 1)], "Udag":[(ops.H, 0), (ops.X, 1)],
    "NSamples":50,
    "TimeEst":5,
    "Hint":"""This your first problem to solve in your groups.
The circuit consists of only 2 gates! One on each qubit. We promise the gates are only
from [X, H] - it's your job to work out what ones.
"""
}

if 1 in args.problems:
    D_problem_1 = add_samples(D_problem_1)
    print("done 1")

D_problem_2 = {
    "Name":"discrete_problem2",
    "NumQubits":2,
    "U":[(ops.H, 0), (ops.X, 1), (ops.CNOT, slice(0, 2, 1)), (ops.Y, 1)], "Udag":None,
    "NSamples":500,
    "TimeEst":5,
    "Hint":"""Problem 2: multiple qubit gates. You will need to try interacting
the qubits with one another using CNOT gates.
CNOT gates are only applied to neighbouring qubits.
Other gates are from [H, X, Y].
"""
}

if 2 in args.problems:
    D_problem_2 = add_samples(D_problem_2)
    print("done 2")

D_problem_3 = {
    "Name":"discrete_problem3",
    "NumQubits":4,
    "U":[(ops.H, i) for i in range(4)] +
        [(ops.CNOT, slice(2, 4, 1))],
    "Udag":None,
    "NSamples":5000,
    "TimeEst":60,
    "Hint":"""A larger problem with a 2 qubit gate.
There is a single one qubit operation [H, X, Y] on each qubit to start,
and then a single CNOT linking 2 neighbouring gates.

You will need to restrict the search to only the depth-5 circuits that have this
structure.
"""
}

if 3 in args.problems:
    t0 = time.time()
    D_problem_3 = add_samples(D_problem_3)
    print(f"done 3 in {time.time()-t0}")

C_problem_4 = {
    "Name":"continuous_problem4",
    "NumQubits":4,
    "Udag":None,
    "NSamples":500,
    "TimeEst":120,
    "Hint":"""Continuous problem with 4 qubits.
This problem is based on a "state preperation circuit" for VQE - used in quantum chemistry.
The circuit is called the Hardware Efficent Ansatz and you can see it in continuous_solver.
You should use the continuous_solver for this and larger continuous problems.
"""
}

if 4 in args.problems:
    depth = 5
    num_qubits = C_problem_4["NumQubits"]
    num_params = num_qubits * (3*depth + 2)
    param_values = np.random.uniform(low=0.0, high=2.0*np.pi, size=(num_params,))
    circuit = []
    p_idx_subset = list(range(num_params))
    for d in range(depth+1):
        if d == 0:
            # strip the params we need for this depth
            p_idx_subset, localps = p_idx_subset[2*num_qubits:], p_idx_subset[:2*num_qubits]
            # logger.debug(f"local parmaters: {len(localps)}")
            for i in range(num_qubits):
                circuit.append( (ops.Rx(param_values[localps[i*2]]), i) )
                circuit.append( (ops.Rz(param_values[localps[i*2+1]]), i) )
        else:
            p_idx_subset, localps = p_idx_subset[3*num_qubits:], p_idx_subset[:3*num_qubits]

            for i in range(num_qubits):
                circuit.append( (ops.Rz(param_values[localps[i*3]]), i) )
                circuit.append( (ops.Rx(param_values[localps[i*3+1]]), i) )
                circuit.append( (ops.Rz(param_values[localps[i*3+2]]), i) )

        for qi in range(num_qubits-1):
            circuit.append( (ops.CNOT, slice(qi, qi+2, 1)))

    C_problem_4["U"] = circuit
    C_problem_4 = add_samples(C_problem_4)
    print("done 4")


C_problem_5 = {
    "Name":"continuous_problem5",
    "NumQubits":6,
    "Udag":None,
    "NSamples":200,
    "TimeEst":120,
}

if 5 in args.problems:

    num_qubits = C_problem_5["NumQubits"]
    param_values = np.random.uniform(low=0.0, high=2.0*np.pi, size=num_qubits)
    circuit = []

    rot_arr = [ops.Rx, ops.Ry, ops.Rz]
    rots = np.random.choice(rot_arr, size=num_qubits)
    for iq, (rot, theta) in enumerate(zip(rots, param_values)):
        circuit.append( (rot(theta), iq) )

    control_arr = [ops.C(ops.X), ops.C(ops.H), ops.C(ops.Y)]
    controls = np.random.choice(control_arr, size=num_qubits-1)
    #for iq, control in enumerate(controls):
    #    circuit.append( (control, slice(iq, iq+2, 1)) )
    circuit.append( (ops.C(ops.H), slice(-1,-1-num_qubits,-num_qubits+1)) ) # loop the last control around.


    print(circuit)
    C_problem_5["U"] = circuit
    C_problem_5 = add_samples(C_problem_5)

    # add drawing for the hint.
    qr = QuantumRegister(num_qubits, "qr")
    circ = QuantumCircuit(qr)

    for iq, (rot, theta) in enumerate(zip(rots, param_values)):
        if rot == ops.Rx:
            circ.rx(0.0, qr[iq])
        if rot == ops.Ry:
            circ.ry(0.0, qr[iq])
        if rot == ops.Rz:
            circ.rz(0.0, qr[iq])

    #for iq, control in enumerate(controls):
    #    if control == ops.C(ops.X):
    #        circ.cx(qr[iq], qr[iq+1])
    #    if control == ops.C(ops.H):
    #        circ.ch(qr[iq], qr[iq+1])
    #    if control == ops.C(ops.Y):
    #        circ.cy(qr[iq], qr[iq+1])

    circ.ch(qr[num_qubits-1], qr[0]) # loop the last control around.

    circascii = circ.draw().single_string()


    C_problem_5["Hint"] = """In this circuit we wrap round a control in order to require a _very_ large circuit of the type you used
for problem 4. In order to solve this you will need to invert the circuit we are giving explicity:
"""
    C_problem_5["Hint"] += circascii
    C_problem_5["Hint"] += """
You need to optimise over the rotations. The angle is given above as 0, but it can be anything from 0 to 2pi."""

    print("done 5")



import pickle
def save_train_data(problem):
    fname = problem["Name"] + ".pyz"
    try:
        del problem["U"]
    except KeyError:
        pass

    try:
        del problem["Udag"]
    except KeyError:
        pass

    with open(fname, "wb") as f:
        pickle.dump(problem, f)

problems = [D_problem_0, D_problem_1, D_problem_2, D_problem_3, C_problem_4, C_problem_5]
for pi in args.problems:
    save_train_data(problems[pi])


def evaluate(problem, trainfn):
    t0 = time.time()
    predictfn = trainfn( zip(problem["TrainSamples"], problem["TrainLabels"]) )
    dt = time.time() - t0

    cost = 0.0
    for testvec, testres in zip(problem["TestVectors"], problem["TestLabels"]):
        p = predictfn(testvec)
        cost += abs(p-testres)

    # print("error in your solution was {}, taking {:+02.3f}s to train.".format(cost, float(dt)))
    if dt > problem["TimeEst"]:
        print(f"It took more than {problem['TimeEst']} to train your solution - we are sure there is a better method!")
