from .helper_functions import compute_parity_exp_value, inference_retval, print_circuit
from qiskit import QuantumCircuit, QuantumRegister, BasicAer, execute
import numpy as np

def manual_solver(training_data):
    # we ignore the training data as we will look at it by hand!
    print("Training data:")
    for training_vec in training_data:
        print("\t{}".format(training_vec))

    num_qubits = int(np.log2(len(training_data[0][0])))
    qr = QuantumRegister(num_qubits, "qr")
    circ = QuantumCircuit(qr)
    simulator = BasicAer.get_backend('statevector_simulator')

    # you will modify this line as part of the first session of the day.
    # note that H is self-inverse (like a classical NOT): H^-1 == H.
    circ.h(qr[0])

    print("Trying the following hand-built circuit:")
    print(print_circuit(circ, num_qubits))


    def infer(input_vector):
        execution_result = execute(circ, simulator, backend_options={"initial_statevector": input_vector}).result()
        prediction = compute_parity_exp_value(execution_result.get_statevector(circ))
        return prediction


    ## Assessing performance on the training set:
    #
    training_error = 0.0
    for train_vector, train_label in training_data:
        prediction = infer(train_vector)
        print('"Prediction" for a training example: {}'.format(prediction))
        training_error += abs(train_label - prediction)

    return inference_retval(
            infer_fun = infer,
            infer_circ = circ,
            description = "Circuit generated by hand."
        )
