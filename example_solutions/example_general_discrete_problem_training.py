from .helper_functions import compute_parity_exp_value, infererance_retval, print_circuit, gate_repr
from qiskit import QuantumCircuit, QuantumRegister, BasicAer, execute
import itertools
import numpy as np

def example_general_discrete_problem_training(training_data):
    """The example training function for the users.
    This is for the discrete problems (staring with D), continuous problems
    have a different train function.

    Lots of opportunities exist for speeding this up. We have used this function internally
    to annotate all problems with the expected training time and will report if you beat that
    or not!
    """

    num_qubits = int(np.log2(len(training_data[0][0]))) # the wavefunction has 2**NQ elements.

    # This list does not contain every gate - you may need to extend it.
    # Here a "gate" is a function that takes the circuit and qreg (created later)
    # We need this as gates are methods on the circuits rather than independent objects in Qiskit.
    # FORMAT: lambda qiskit gate specification, string description of gate/qubit
    allowable_gates = []
    for i in range(num_qubits):
        allowable_gates.extend([
            lambda circ, qreg, i=i: circ.h(qreg[i]),
            lambda circ, qreg, i=i: circ.x(qreg[i]),
        ])
        if num_qubits>1:
            allowable_gates.append(
                lambda circ, qreg, i=i: circ.cx(qreg[i], qreg[(i+1) % num_qubits]),
            )
    print('-' * 80)
    print("Allowable gates:")
    for current_gate in allowable_gates:
        q = QuantumRegister(num_qubits, "q")
        c = QuantumCircuit(q)
        current_gate(c, q)
        print(print_circuit(c,num_qubits))
    print('-' * 80)

    max_depth = num_qubits * 2 # the total number of gates to consider
    print(f"Maximum gate depth {max_depth}")

    # NOTE: some gates are not affected by ordering!
    # for example, 2 gates on 2 different qubits can be exchanged.
    # this is not considered here.
    possible_circuits = itertools.chain(*[
                        itertools.permutations((gates for gates in allowable_gates), r=NG)
                        for NG in range(max_depth+1)
                       ])

    possible_circuits = list(possible_circuits)
    print(f"Number of possible circuits to consider: {len(possible_circuits)}")

    simulator = BasicAer.get_backend('statevector_simulator')
    best_cost = float('Inf')
    best_circuit = None
    best_circ    = None

    for current_circuit in possible_circuits:

        ## Building a Qiskit circuit from our internal representation:
        #
        qr = QuantumRegister(num_qubits, "qr")
        circ = QuantumCircuit(qr)
        if len(current_circuit) == 0:
            circ.iden(qr)
        else:
            for gate_application_function in current_circuit:
                gate_application_function(circ, qr)

        ## Assessing performance on the training set:
        #
        current_cost = 0.0
        for train_vector, train_label in training_data:
            execution_result = execute(circ, simulator, backend_options={"initial_statevector": train_vector}).result()
            predicted_label = compute_parity_exp_value(execution_result.get_statevector(circ))
            current_cost += abs(train_label - predicted_label)
        print(f"For circuit {' -> '.join(gate_repr(g) for g in current_circuit)}, training error was {current_cost:.2f}.")

        if current_cost < best_cost:
            best_circuit    = current_circuit
            best_circ       = circ
            best_cost       = current_cost
        # if best_cost == 0.0:
        #     break # done!

    print("Done")
    print("Best circuit:")
    print(print_circuit(best_circuit, num_qubits))
    print(f"with training_error {best_cost}")


    ## The inference function takes a state and predicts a label:
    #
    def infer(input_vector):
        execution_result = execute(best_circ, simulator, backend_options={"initial_statevector": input_vector}).result()
        predicted_label = compute_parity_exp_value(execution_result.get_statevector(best_circ))
        return predicted_label


    return infererance_retval(
            infer_fun = infer,
            infer_circ = best_circuit,
            discription = "Circuit generated by exhaustive search.",
            training_error = best_cost,
            train_accuracy = best_cost/len(training_data)*100
        )
